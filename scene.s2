(lambda (x y res) (seq))
; @file prelude

(def qmap (lambda (list)
  (if (= (size list) 0)
    list
    (cons (quasicode (first list)) (qmap (rest list))))))

(def quasicode (lambda (arg)
  (if (not (list? arg)) (quote arg)
    (if (same (first arg) 'unquote)
      (first1 (rest arg))
      (cons 'list (qmap arg))))))

(def quasiquote (macro (arg)
  (quasicode arg)))

(def and (macro (a b) `(if ,a (if ,b true false) false)))

(def or (macro (a b) `(if ,a true (if ,b true false))))

(def quotelist (lambda (list)
  (if (= (size list) 0)
    list
    (cons (quote (first list)) (quotelist (rest list))))))

(def let_fun (lambda (args)
  ; TODO error cases for (= size 0)
  (if (= (size args) 1)
    (first1 args) ; plain body
    (list
      'let1
      (first args)
      (let_fun (rest args))))))


(def let (macro (...)
  (let_fun ...)))

(def require (macro (...) (cons '_require (quotelist ...))))
(def : (macro (base ...) (cons '_element (cons base (quotelist ...)))))

; non-recursive to avoid browser erroring out due to stack overflow
(def slice (lambda (from to args) (let
  (from' from) (to' to) (args' args)
  (res '())
  (seq
    (while (or (> from 0) (> to 0))
      (if (> from 0)
        (seq
          (set from (- from 1))
          (set to (- to 1))
          (set args (rest args)))
        (seq
          (set res (cons (first args) res))
          (set to (- to 1))
          (set args (rest args)))))
    res))))

(def for (macro (var from to body)
  `(seq
    (let (,var ,from)
      (while (< ,var ,to) (let
        (_for_res ,body)
        (seq
          (set ,var (+ ,var 1))
          _for_res)))))))

; TODO vectors?
(def min (lambda (a b)
  (if (< a b) a b)))

(def max (lambda (a b)
  (if (> a b) a b)))

(def sum (lambda (vec) (+ (: vec x) (: vec y) (: vec z))))
(def length (lambda (vec) (sqrt (sum (* vec vec)))))
