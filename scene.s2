(require util group boundgroup color sphere plane)

(lambda () (let
  (fun (average 16 (fuzz (pathtrace 5 (group
    (for/group i 0 10
      (for/group k 0 10
        (for/group l 0 10
          (color (+ 0.8 (* 0.1 (vec3f (rand) (rand) (rand))))
            (sphere (vec3f
                (/ (- i 4.5) 2.5)
                (+ -0.8 (/ l 2.5))
                (+ 5 (/ (- k 4.5) 2.5)))
              0.2)))))
    (group
      (plane (vec3f 0 1 0) (vec3f 0 -1 0))
      (shine (vec3f 1) (color (vec3f 0) (plane (vec3f 0 -1 0) (vec3f 0 10 0))))))))))
  
  (fn (get-scenefun fun))
  (lambda (x y res) (let
    (ray (coords-ray x y))
    (seq
      (rand_seed (+ x (* y dw)))
      (fn ray res))))))
; @file prelude
(def qmap (lambda (list)
  (if (= (size list) 0)
    list
    (cons (quasicode (first list)) (qmap (rest list))))))

(def quasicode (lambda (arg)
  (if (not (list? arg)) (quote arg)
    (if (same (first arg) 'unquote)
      (first1 (rest arg))
      (cons 'list (qmap arg))))))

(def quasiquote (macro (arg)
  (quasicode arg)))

(def and (macro (a b) `(if ,a (if ,b true false) false)))

(def or (macro (a b) `(if ,a true (if ,b true false))))

(def quotelist (lambda (list)
  (if (= (size list) 0)
    list
    (cons (quote (first list)) (quotelist (rest list))))))

(def let_fun (lambda (args)
  ; TODO error cases for (= size 0)
  (if (= (size args) 1)
    (first1 args) ; plain body
    (list
      'let1
      (first args)
      (let_fun (rest args))))))


(def let (macro (...)
  (let_fun ...)))

(def require (macro (...) (cons '_require (quotelist ...))))
(def : (macro (base ...) (cons '_element (cons base (quotelist ...)))))

(def for (macro (var from to body)
  `(seq
    (let (,var ,from)
      (while (< ,var ,to) (let
        (_for_res ,body)
        (seq
          (set ,var (+ ,var 1))
          _for_res)))))))

; TODO vectors?
(def min (lambda (a b)
  (if (< a b) a b)))

(def max (lambda (a b)
  (if (> a b) a b)))

(def sum (lambda (vec) (+ (: vec x) (: vec y) (: vec z))))
(def length (lambda (vec) (sqrt (sum (* vec vec)))))
; @file util
(def scenefun (closure-type
  (list
    (typeof (make-ray))
    (typeof (make-res)))
  'void))

(def rewrap (macro (fn lamb)
  `(if (struct? ,fn)
    (alloc-struct
      (bound (: ,fn bound))
      (fn (type scenefun ,lamb)))
    ,lamb)))

; flags = outside | inside
(def outside (lambda (ray newstate)
  (set (: ray flags) (| (& (: ray flags) 1) (if newstate 2 0)))))

(def outside? (lambda (ray)
  (= (& (: ray flags) 2) 2)))

(def inside (lambda (ray newstate)
  (set (: ray flags) (| (& (: ray flags) 2) (if newstate 1 0)))))

(def inside? (lambda (ray)
  (= (& (: ray flags) 1) 1)))

; http://burtleburtle.net/bob/rand/smallprng.html
(def rand_a 0)
(def rand_b 0)
(def rand_c 0)
(def rand_d 0)

(def rand32 (lambda () (let
  (e (- rand_a (| (<< rand_b 27) (>>> rand_b 5))))
  (seq
    (set rand_a (^ rand_b (| (<< rand_c 17) (>>> rand_c 15))))
    (set rand_b (+ rand_c rand_d))
    (set rand_c (+ rand_d e))
    (set rand_d (+ e rand_a))
    (>>> rand_d 0)))))

(def rand (lambda () (let
  (r (rand32))
  (s (+ 0 r))
  (t (/ s 4294967295))
  t)))

(def rand_seed (lambda (seed) (seq
  (set rand_a 0xf1ea5eed)
  (set rand_b seed)
  (set rand_c seed)
  (set rand_d seed)
  (for i 0 20 (rand32)))))

(rand_seed 17)

(def length-squared (lambda (vec) (sum (* vec vec))))
(def normalized (lambda (vec) (* vec (/ 1 (length vec)))))

(def dot (lambda (a b) (sum (* a b))))

(def rand-sphere (type (function-type (list) 'vec3f) (lambda () (let
  (rand2 (lambda () (- (* (rand) 2) 1)))
  (v (vec3f (rand2) (rand2) (rand2)))
  (if (<= (length v) 1)
    v
    (rand-sphere))))))

(def rand-halfsphere (lambda (normal) (let
  (r (normalized (rand-sphere)))
  (if (< (dot normal r) 0)
    (- 0 r)
    r))))

(def cos-weighted-halfsphere (type (function-type (list 'vec3f) 'vec3f) (lambda (normal) (let
  (v' (normalized (rand-sphere)))
  (d' (dot normal v'))
  (v (if (< d' 0) (- 0 v') v'))
  (d (if (< d' 0) (- 0 d') d'))
  (if (<= (rand) d)
    v
    (cos-weighted-halfsphere normal))))))

(def get-scenefun (lambda (thing) (seq
  (if (struct? thing)
    (: thing fn)
    thing))))

(def make-bound (lambda (from to)
  (alloc-struct (from from) (to to))))

(def coords-ray-flat (lambda (x y) (let
  (ratio (/ dw dh))
  (ray (alloc-ray))
  (seq
    (inside ray false)
    (set (: ray pos) (vec3f
      0
      0
      (/ (- projscale) fov)))
    (set (: ray dir) (normalized (vec3f
      (* ratio fov (- (/ x (/ dw 2)) 1))
      (* fov (- 1 (/ y (/ dh 2))))
      1)))
    ray))))

(def latlon-to-dir (lambda (lat lon) (let
  (clat (cos lat))
  (vec3f (* clat (sin lon)) (sin lat) (* clat (cos lon))))))

(def coords-dir-panini (lambda (x y) (let
  (sqr (lambda (v) (* v v)))
  (d 1)
  (k (/ (sqr x) (sqr (+ d 1))))
  (dscr (- (* (sqr k) (sqr d)) (* (+ k 1) (- (* k (sqr d)) 1))))
  (sq (sqrt dscr))
  (kd (* k d))
  (clon (/ (- sq kd) (+ k 1)))
  (S (/ (+ d 1) (+ d clon)))
  (lon (atan2 x (* S clon)))
  (lat (atan2 y S))
  (latlon-to-dir lat lon))))

(def coords-ray-panini (lambda (x y) (let
  (ratio (/ dw dh))
  (ray (alloc-ray))
  (vx (- (* 2 (/ x dw)) 1)) ; -1..1
  (vy (- (* 2 (/ y dh)) 1)) ; -1..1
  (seq
    (inside ray false)
    (set vx (* vx ratio fov))
    (set vy (* vy -1 fov))
    (set (: ray pos) (vec3f
      0
      0
      (/ (- projscale) fov)))
    (set (: ray dir) (normalized (coords-dir-panini vx vy)))
    ray))))

(def coords-ray coords-ray-panini)

(def fuzz (lambda (fn)
  (lambda (ray res) (let
    (ray2 (make-ray ray))
    (seq
      (set (: ray2 pos) (: ray pos))
      (set (: ray2 dir) (normalized (
        +
        (vec3f (/ (rand) dw) (/ (rand) dh) 0)
        (: ray dir))))
      (fn ray2 res))))))

(def pathtrace_internal (type
  (function-type
    (list
      (typeof (make-ray))
      (typeof (make-res))
      scenefun
      'int)
    'void)
  (lambda (ray res fn depth) (seq
    (set (: res success) false)
    (fn ray res)
    (if (and
        (> depth 0)
        (and
          (: res success)
          (and
            (isfinite (: res distance))
            (> (length-squared (: res reflect)) 0))))
      (let
        (ray2 (make-ray ray))
        (startpos (+
          (: ray pos)
          (* (: ray dir) (: res distance))))
        (res2 (make-res))
        (seq
          (set (: ray2 pos) startpos)
          (set (: ray2 dir) (cos-weighted-halfsphere (: res normal)))
          (pathtrace_internal ray2 res2 fn (- depth 1))
          (if (: res2 success)
            (set (: res emit)
              (+ (: res emit) (* (: res reflect) (: res2 emit))))))))))))

(def pathtrace (lambda (depth scene) (let
  (fn (get-scenefun scene))
  (lambda (ray res) (pathtrace_internal ray res fn depth)))))

(def average (lambda (count scenefun)
  (lambda (ray res) (let
    (color-sum (vec3f 0 0 0))
    (seq
      (for i 0 count (seq
        (scenefun ray res)
        (let
          (color (if (: res success)
            (: res emit)
            (vec3f 1 0 0)))
          (set color-sum (+ color-sum color)))))
      (set (: res emit) (/ color-sum count)))))))
; @file sphere
(require util)

(def sphere (lambda (center radius) (let
  (rsq (* radius radius))
  (alloc-struct
    (bound (make-bound (- center (vec3f radius)) (+ center (vec3f radius))))
    (fn (type scenefun (lambda (ray res) (let
      (pos (- (: ray pos) center))
      (dir (: ray dir))
      (p (sum (* 2 pos dir)))
      (inside (- (+ rsq (* p p (/ 1 4))) (sum (* pos pos))))
      (if (>= inside 0)
        (let
          (sq (sqrt inside))
          (k (- 0 (/ p 2)))
          (k1 (- k sq))
          (k2 (+ k sq))
          (if (or (> k1 0) (and (inside? ray) (> k2 0))) (let
            (distance (if (and (> k1 0) (outside? ray)) k1 k2))
            (seq
              (set (: res success) true)
              (set (: res distance) distance)
              (set (: res normal) (+ pos (* dir distance)))
              (set (: res emit) (vec3f 0))
              (set (: res reflect) (vec3f 1)))))))))))))))
; @file bound
(require util)

(def get-bounding-box (lambda (obj)
  (if (struct? obj)
    (: obj bound)
    (make-bound (vec3f (- 0 Infinity)) (vec3f Infinity)))))

(def merge-bounding-box (lambda (box1 box2) (seq
  (make-bound
    (vec3f
      (min (: box1 from x) (: box2 from x))
      (min (: box1 from y) (: box2 from y))
      (min (: box1 from z) (: box2 from z)))
    (vec3f
      (max (: box1 to x) (: box2 to x))
      (max (: box1 to y) (: box2 to y))
      (max (: box1 to z) (: box2 to z)))))))

(def infinite-sized-box (lambda (box)
  (and
    (and (= (: box from x) (- 0 Infinity))
      (and
        (= (: box from y) (- 0 Infinity))
        (= (: box from z) (- 0 Infinity))))
    (and (= (: box to x) Infinity)
      (and
        (= (: box to y) Infinity)
        (= (: box to z) Infinity))))))

(def ray_hits_bound (lambda (from to ray) (let
  (enter (vec3f (- 0 Infinity)))
  (exit (vec3f Infinity))
  ; shift ray into origin
  (rfrom (- from (: ray pos)))
  (rto (- to (: ray pos)))
  (dir (: ray dir))
  (seq
    (if (!= (: dir x) 0) (let
      (a (/ (: rfrom x) (: dir x)))
      (b (/ (: rto x) (: dir x)))
      (seq
        (set (: enter x) (min a b))
        (set (: exit x) (max a b)))))
    (if (!= (: dir y) 0) (let
      (a (/ (: rfrom y) (: dir y)))
      (b (/ (: rto y) (: dir y)))
      (seq
        (set (: enter y) (min a b))
        (set (: exit y) (max a b)))))
    (if (!= (: dir z) 0) (let
      (a (/ (: rfrom z) (: dir z)))
      (b (/ (: rto z) (: dir z)))
      (seq
        (set (: enter z) (min a b))
        (set (: exit z) (max a b)))))
    (let
      (last_entry (max (max (: enter x) (: enter y)) (: enter z)))
      (first_exit (min (min (: exit x) (: exit y)) (: exit z)))
      ; if entry is before exit, and exit is ahead of us
      (and (>= first_exit last_entry) (>= first_exit 0)))))))

(def bound (lambda (from to obj) (let
  (fn (get-scenefun obj))
  (rewrap obj (lambda (ray res) (seq
    (if (ray_hits_bound from to ray)
      (fn ray res))))))))
; @file plane
(require util)

(def plane (lambda (normal base)
  (type scenefun (lambda (ray res) (let
    (pos (: ray pos))
    (dir (: ray dir))
    (denom (sum (- 0 (* dir normal))))
    (predist (sum (* normal (- pos base))))
    (if (> (* denom predist) 0)
      (seq
        (set (: res success) true)
        (set (: res reflect) (vec3f 1))
        (set (: res emit) (vec3f 0))
        (set (: res normal) normal)
        (if (> denom 0)
          (set (: res distance) (/ predist denom))
          (set (: res distance) (/ 1 0))))))))))
; @file color
(require util)

;; (def reflect-at (lambda (normal incoming) (let
;;   (n normal)
;;   (a (- 0 incoming))
;;   (k (/ (dot a n) (dot n n)))
;;   (- (* 2 k n) a))))
;; 
;; (def reflect (lambda (factor obj) (let
;;   (fn (get-scenefun obj))
;;   (rewrap obj (lambda (ray res) (seq
;;     (fn ray res)
;;     (if (and
;;         (: res success)
;;         (isfinite (: res distance)))
;;       (let
;;         (ray2 (make-ray ray))
;;         (startpos (+
;;           (: ray pos)
;;           (* (: ray dir) (: res distance))))
;;         (res2 (make-res))
;;         (seq
;;           (set (: ray2 pos) startpos)
;;           (set (: ray2 dir) (reflect-at (: res normal) (: ray dir)))
;;           (fn ray2 res2) ; !!WRONG!! TODO RECURSE IN PATHTRACE INSTEAD
;;           (if (: res2 success)
;;             (set (: res emit)
;;               (+ (: res emit) (* factor (: res2 emit))))))))))))))

(def shine (lambda (color obj) (let
  (fn (get-scenefun obj))
  (rewrap obj (lambda (ray res) (seq
    (fn ray res)
    (set (: res emit) color)))))))

(def color (lambda (color obj) (let
  (fn (get-scenefun obj))
  (rewrap obj (lambda (ray res) (seq
    (fn ray res)
    (set (: res reflect) color)))))))
; @file group
(require util bound)

(def group (lambda (obj1 obj2) (let
  (fn1 (get-scenefun obj1))
  (fn2 (get-scenefun obj2))
  (alloc-struct
    (bound (merge-bounding-box
      (get-bounding-box obj1)
      (get-bounding-box obj2)))
    (fn (type scenefun (lambda (ray res1) (let
      (res2 (make-res))
      (seq
        (fn1 ray res1)
        (fn2 ray res2)
        (if (and (: res2 success) (not (: res1 success)))
          (set res1 res2)
        (if (and (: res1 success) (: res2 success))
          (if (< (: res2 distance) (: res1 distance))
            (set res1 res2)))))))))))))
; @file nothing
(def nothing (lambda ()
  (lambda (ray res) true)))
; @file boundgroup
(require util bound group)

(def bound-group (lambda (a b) (let
  (box1 (get-bounding-box a))
  (box2 (get-bounding-box b))
  (combined-box (merge-bounding-box box1 box2))
  (if (infinite-sized-box combined-box)
    ; then
    (group a b)
    ; else
    (bound
      (: combined-box from)
      (: combined-box to)
      (group a b))))))

(def for/group-body (lambda (from to fn)
  (if (= from to)
    '(nothing)
    (if (= (+ 1 from) to)
      `(,fn ,from)
      (let
        (pivot (+ from (floor (/ (- to from) 2))))
        (left (for/group-body from pivot fn))
        (right (for/group-body pivot to fn))
        `(bound-group ,left ,right))))))

(def for/group (macro (var from to body)
  `(let (%fgbody (lambda (,var) ,body))
    ,(for/group-body from to `%fgbody))))

